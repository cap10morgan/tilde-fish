use clojure_reader::edn::Edn;
use std::collections::BTreeMap;

fn main() {
    let args: Vec<String> = std::env::args().collect();

    if args.len() > 1 && args[1] == "--config" {
        let config = plugin_config();
        println!("{}", config);
        return;
    }

    if args.len() > 1 && args[1] == "--gen-config" {
        // Read from stdin
        let mut input = String::new();
        std::io::Read::read_to_string(&mut std::io::stdin(), &mut input)
            .expect("Failed to read from stdin");

        // Parse the EDN
        let cfg = clojure_reader::edn::read_string(&input).expect("Failed to parse EDN from stdin");

        let config = fish_config(cfg);
        println!("{}", config);
        return;
    }

    if args.len() < 3 {
        eprintln!(
            "Usage: {} [pattern] [path] or {} --config or {} --gen-config < input.edn",
            args[0], args[0], args[0]
        );
        std::process::exit(1);
    }
}

fn plugin_config() -> String {
    let mut files_map = BTreeMap::new();
    files_map.insert(Edn::Key("fish"), Edn::Str("fish/config.fish"));

    let mut generators_map = BTreeMap::new();
    generators_map.insert(Edn::Key("fish"), Edn::Str("--gen-config"));

    let mut preambles_map = BTreeMap::new();
    preambles_map.insert(
        Edn::Key("tilde/all"),
        Edn::Str("# This config generated by tilde; DO NOT MODIFY\\n"),
    );

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("name"), Edn::Key("fish"));
    config_map.insert(Edn::Key("files"), Edn::Map(files_map));
    config_map.insert(Edn::Key("generators"), Edn::Map(generators_map));
    config_map.insert(Edn::Key("preambles"), Edn::Map(preambles_map));

    // The Edn type implements Display, so we can just use fmt
    format!("{}", Edn::Map(config_map))
}

fn fish_config(config: Edn) -> String {
    let mut output = String::new();

    // Add preamble if present
    if let Edn::Map(config_map) = &config {
        if let Some(Edn::Map(preambles)) = config_map.get(&Edn::Key("preambles")) {
            if let Some(Edn::Str(preamble)) = preambles.get(&Edn::Key("tilde/all")) {
                output.push_str(&preamble.replace("\\n", "\n"));
                output.push('\n');
            }
        }
    }

    // Process the config to generate fish shell configuration
    match config {
        Edn::Map(config_map) => {
            // Handle fish-greeting
            if let Some(Edn::Str(fish_greeting)) = config_map.get(&Edn::Key("fish-greeting")) {
                output.push_str(&format!("set fish_greeting '{}'\n", fish_greeting));
            } else {
                if config_map.contains_key(&Edn::Key("fish-greeting")) {
                    output.push_str("set fish_greeting\n");
                }
            }
            output.push('\n');

            // Handle snippets
            for (key, value) in config_map.iter() {
                if let Edn::Key(key_str) = key {
                    if key_str.starts_with("snippet/") {
                        if let Edn::Str(snippet_content) = value {
                            output.push_str(&format!("# {}\n", &key_str.replace("snippet/", "")));
                            let snippet =
                                snippet_content.replace("\\n", "\n").replace("\\\"", "\"");
                            output.push_str(&snippet);
                            output.push('\n');
                        }
                    }
                }
            }

            // Handle abbreviations
            if let Some(Edn::Map(abbrs)) = config_map.get(&Edn::Key("abbrs")) {
                output.push_str("# Abbreviations\n");
                for (key, value) in abbrs {
                    match (key, value) {
                        (Edn::Key(abbr_name), Edn::Str(abbr_expansion)) => {
                            output.push_str(&format!(
                                "abbr -a -- {} '{}'\n",
                                abbr_name, abbr_expansion
                            ));
                        }
                        (Edn::Str(abbr_name), Edn::Str(abbr_expansion)) => {
                            output.push_str(&format!(
                                "abbr -a -- {} '{}'\n",
                                abbr_name, abbr_expansion
                            ));
                        }
                        _ => {}
                    }
                }
                output.push('\n');
            }

            // Handle aliases
            if let Some(Edn::Map(aliases)) = config_map.get(&Edn::Key("aliases")) {
                output.push_str("# Aliases\n");
                for (key, value) in aliases {
                    match (key, value) {
                        (Edn::Key(alias_name), Edn::Str(alias_command)) => {
                            output.push_str(&format!("alias {} '{}'\n", alias_name, alias_command));
                        }
                        (Edn::Str(alias_name), Edn::Str(alias_command)) => {
                            output.push_str(&format!("alias {} '{}'\n", alias_name, alias_command));
                        }
                        _ => {}
                    }
                }
                output.push('\n');
            }

            // Handle environment variables
            if let Some(Edn::Map(env_vars)) = config_map.get(&Edn::Key("env")) {
                output.push_str("# Environment Variables\n");
                for (key, value) in env_vars {
                    match (key, value) {
                        (Edn::Key(var_name), Edn::Str(var_value)) => {
                            output.push_str(&format!("set -gx {} '{}'\n", var_name, var_value));
                        }
                        (Edn::Str(var_name), Edn::Str(var_value)) => {
                            output.push_str(&format!("set -gx {} '{}'\n", var_name, var_value));
                        }
                        _ => {}
                    }
                }
                output.push('\n');
            }

            // Handle PATH additions
            if let Some(Edn::Vector(paths)) = config_map.get(&Edn::Key("paths")) {
                output.push_str("# PATH additions\n");
                for path in paths {
                    if let Edn::Str(path_str) = path {
                        output.push_str(&format!("fish_add_path {}\n", path_str));
                    }
                }
                output.push('\n');
            }

            // Handle functions
            if let Some(Edn::Map(functions)) = config_map.get(&Edn::Key("functions")) {
                output.push_str("# Functions\n");
                for (key, value) in functions {
                    match (key, value) {
                        (Edn::Key(func_name), Edn::Str(func_body)) => {
                            output.push_str(&format!("function {}\n", func_name));
                            // Handle multi-line function bodies with proper newline processing
                            let processed_body = func_body.replace("\\n", "\n");
                            for line in processed_body.lines() {
                                if !line.trim().is_empty() {
                                    output.push_str(&format!("    {}\n", line));
                                }
                            }
                            output.push_str("end\n\n");
                        }
                        (Edn::Str(func_name), Edn::Str(func_body)) => {
                            output.push_str(&format!("function {}\n", func_name));
                            // Handle multi-line function bodies with proper newline processing
                            let processed_body = func_body.replace("\\n", "\n");
                            for line in processed_body.lines() {
                                if !line.trim().is_empty() {
                                    output.push_str(&format!("    {}\n", line));
                                }
                            }
                            output.push_str("end\n\n");
                        }
                        _ => {}
                    }
                }
            }

            // Handle raw fish commands
            if let Some(Edn::Vector(commands)) = config_map.get(&Edn::Key("fish")) {
                output.push_str("# Custom Fish Commands\n");
                for command in commands {
                    if let Edn::Str(cmd_str) = command {
                        output.push_str(&format!("{}\n", cmd_str));
                    }
                }
                output.push('\n');
            }

            // Handle prompt configuration
            if let Some(Edn::Map(prompt_config)) = config_map.get(&Edn::Key("prompt")) {
                output.push_str("# Prompt Configuration\n");
                if let Some(Edn::Str(prompt_style)) = prompt_config.get(&Edn::Key("style")) {
                    output.push_str(&format!("set -g theme {}\n", prompt_style));
                }
                if let Some(Edn::Bool(show_git)) = prompt_config.get(&Edn::Key("show-git")) {
                    output.push_str(&format!(
                        "set -g fish_prompt_show_git {}\n",
                        if *show_git { "true" } else { "false" }
                    ));
                }
                output.push('\n');
            }
        }
        _ => {
            // If config is not a map, return a basic config
            output.push_str("# Basic fish configuration\n");
        }
    }

    output
}
