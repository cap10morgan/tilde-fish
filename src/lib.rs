use clojure_reader::edn::Edn;
use std::collections::BTreeMap;

pub fn plugin_config() -> String {
    let mut files_map = BTreeMap::new();
    files_map.insert(Edn::Key("fish"), Edn::Str("fish/config.fish"));

    let mut generators_map = BTreeMap::new();
    generators_map.insert(Edn::Key("fish"), Edn::Str("--gen-config"));

    let mut preambles_map = BTreeMap::new();
    preambles_map.insert(
        Edn::Key("tilde/all"),
        Edn::Str("# This config generated by tilde; DO NOT MODIFY\\n"),
    );

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("name"), Edn::Key("fish"));
    config_map.insert(Edn::Key("files"), Edn::Map(files_map));
    config_map.insert(Edn::Key("generators"), Edn::Map(generators_map));
    config_map.insert(Edn::Key("preambles"), Edn::Map(preambles_map));

    // The Edn type implements Display, so we can just use fmt
    format!("{}", Edn::Map(config_map))
}

pub fn fish_config(config: Edn) -> String {
    let mut output = String::new();

    // Add preamble if present
    if let Edn::Map(config_map) = &config {
        if let Some(Edn::Map(preambles)) = config_map.get(&Edn::Key("preambles")) {
            if let Some(Edn::Str(preamble)) = preambles.get(&Edn::Key("tilde/all")) {
                output.push_str(&preamble.replace("\\n", "\n"));
                output.push('\n');
            }
        }
    }

    // Process the config to generate fish shell configuration
    match config {
        Edn::Map(config_map) => {
            // Handle fish-greeting
            if let Some(Edn::Str(fish_greeting)) = config_map.get(&Edn::Key("fish-greeting")) {
                output.push_str(&format!("set fish_greeting '{}'\n", fish_greeting));
            } else if config_map.contains_key(&Edn::Key("fish-greeting")) {
                output.push_str("set fish_greeting\n");
            }
            output.push('\n');

            // Handle snippets
            for (key, value) in config_map.iter() {
                if let Edn::Key(key_str) = key {
                    if key_str.starts_with("snippet/") {
                        if let Edn::Str(snippet_content) = value {
                            output.push_str(&format!("# {}\n", &key_str.replace("snippet/", "")));
                            let snippet =
                                snippet_content.replace("\\n", "\n").replace("\\\"", "\"");
                            output.push_str(&snippet);
                            output.push('\n');
                        }
                    }
                }
            }

            // Handle abbreviations
            if let Some(Edn::Map(abbrs)) = config_map.get(&Edn::Key("abbrs")) {
                output.push_str("# Abbreviations\n");
                for (key, value) in abbrs {
                    match (key, value) {
                        (Edn::Key(abbr_name), Edn::Str(abbr_expansion)) => {
                            output.push_str(&format!(
                                "abbr -a -- {} '{}'\n",
                                abbr_name, abbr_expansion
                            ));
                        }
                        (Edn::Str(abbr_name), Edn::Str(abbr_expansion)) => {
                            output.push_str(&format!(
                                "abbr -a -- {} '{}'\n",
                                abbr_name, abbr_expansion
                            ));
                        }
                        _ => {}
                    }
                }
                output.push('\n');
            }

            // Handle aliases
            if let Some(Edn::Map(aliases)) = config_map.get(&Edn::Key("aliases")) {
                output.push_str("# Aliases\n");
                for (key, value) in aliases {
                    match (key, value) {
                        (Edn::Key(alias_name), Edn::Str(alias_command)) => {
                            output.push_str(&format!("alias {} '{}'\n", alias_name, alias_command));
                        }
                        (Edn::Str(alias_name), Edn::Str(alias_command)) => {
                            output.push_str(&format!("alias {} '{}'\n", alias_name, alias_command));
                        }
                        _ => {}
                    }
                }
                output.push('\n');
            }

            // Handle environment variables
            if let Some(Edn::Map(env_vars)) = config_map.get(&Edn::Key("env")) {
                output.push_str("# Environment Variables\n");
                for (key, value) in env_vars {
                    match (key, value) {
                        (Edn::Key(var_name), Edn::Str(var_value)) => {
                            output.push_str(&format!("set -gx {} '{}'\n", var_name, var_value));
                        }
                        (Edn::Str(var_name), Edn::Str(var_value)) => {
                            output.push_str(&format!("set -gx {} '{}'\n", var_name, var_value));
                        }
                        _ => {}
                    }
                }
                output.push('\n');
            }

            // Handle PATH additions
            if let Some(Edn::Vector(paths)) = config_map.get(&Edn::Key("paths")) {
                output.push_str("# PATH additions\n");
                for path in paths {
                    if let Edn::Str(path_str) = path {
                        output.push_str(&format!("fish_add_path {}\n", path_str));
                    }
                }
                output.push('\n');
            }

            // Handle functions
            if let Some(Edn::Map(functions)) = config_map.get(&Edn::Key("functions")) {
                output.push_str("# Functions\n");
                for (key, value) in functions {
                    match (key, value) {
                        (Edn::Key(func_name), Edn::Str(func_body)) => {
                            output.push_str(&format!("function {}\n", func_name));
                            // Handle multi-line function bodies with proper newline processing
                            let processed_body = func_body.replace("\\n", "\n");
                            for line in processed_body.lines() {
                                if !line.trim().is_empty() {
                                    output.push_str(&format!("    {}\n", line));
                                }
                            }
                            output.push_str("end\n\n");
                        }
                        (Edn::Str(func_name), Edn::Str(func_body)) => {
                            output.push_str(&format!("function {}\n", func_name));
                            // Handle multi-line function bodies with proper newline processing
                            let processed_body = func_body.replace("\\n", "\n");
                            for line in processed_body.lines() {
                                if !line.trim().is_empty() {
                                    output.push_str(&format!("    {}\n", line));
                                }
                            }
                            output.push_str("end\n\n");
                        }
                        _ => {}
                    }
                }
            }

            // Handle raw fish commands
            if let Some(Edn::Vector(commands)) = config_map.get(&Edn::Key("fish")) {
                output.push_str("# Custom Fish Commands\n");
                for command in commands {
                    if let Edn::Str(cmd_str) = command {
                        output.push_str(&format!("{}\n", cmd_str));
                    }
                }
                output.push('\n');
            }

            // Handle prompt configuration
            if let Some(Edn::Map(prompt_config)) = config_map.get(&Edn::Key("prompt")) {
                output.push_str("# Prompt Configuration\n");
                if let Some(Edn::Str(prompt_style)) = prompt_config.get(&Edn::Key("style")) {
                    output.push_str(&format!("set -g theme {}\n", prompt_style));
                }
                if let Some(Edn::Bool(show_git)) = prompt_config.get(&Edn::Key("show-git")) {
                    output.push_str(&format!(
                        "set -g fish_prompt_show_git {}\n",
                        if *show_git { "true" } else { "false" }
                    ));
                }
                output.push('\n');
            }
        }
        _ => {
            // If config is not a map, return a basic config
            output.push_str("# Basic fish configuration\n");
        }
    }

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use clojure_reader::edn;
    use std::collections::BTreeMap;

    #[test]
    fn test_plugin_config_format() {
        let config = plugin_config();

        // Parse the generated EDN to ensure it's valid
        let parsed = edn::read_string(&config).expect("Plugin config should be valid EDN");

        // Verify it's a map
        if let Edn::Map(config_map) = parsed {
            // Check required keys exist
            assert!(config_map.contains_key(&Edn::Key("name")));
            assert!(config_map.contains_key(&Edn::Key("files")));
            assert!(config_map.contains_key(&Edn::Key("generators")));
            assert!(config_map.contains_key(&Edn::Key("preambles")));

            // Check name value
            assert_eq!(config_map.get(&Edn::Key("name")), Some(&Edn::Key("fish")));
        } else {
            panic!("Plugin config should be an EDN map");
        }
    }

    #[test]
    fn test_empty_config() {
        let config = Edn::Map(BTreeMap::new());
        let result = fish_config(config);

        // Empty config map should produce minimal output (just newlines)
        // since it goes through the Map branch but finds no sections
        assert!(result.trim().is_empty() || result == "\n");
    }

    #[test]
    fn test_fish_greeting_string() {
        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("fish-greeting"), Edn::Str("Welcome to Fish!"));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("set fish_greeting 'Welcome to Fish!'"));
    }

    #[test]
    fn test_fish_greeting_empty() {
        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("fish-greeting"), Edn::Str(""));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("set fish_greeting ''"));
    }

    #[test]
    fn test_aliases() {
        let mut aliases = BTreeMap::new();
        aliases.insert(Edn::Key("ll"), Edn::Str("ls -la"));
        aliases.insert(Edn::Str("grep"), Edn::Str("grep --color=auto"));

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("aliases"), Edn::Map(aliases));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# Aliases"));
        assert!(result.contains("alias ll 'ls -la'"));
        assert!(result.contains("alias grep 'grep --color=auto'"));
    }

    #[test]
    fn test_abbreviations() {
        let mut abbrs = BTreeMap::new();
        abbrs.insert(Edn::Key("gs"), Edn::Str("git status"));
        abbrs.insert(Edn::Str("gc"), Edn::Str("git commit"));

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("abbrs"), Edn::Map(abbrs));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# Abbreviations"));
        assert!(result.contains("abbr -a -- gs 'git status'"));
        assert!(result.contains("abbr -a -- gc 'git commit'"));
    }

    #[test]
    fn test_environment_variables() {
        let mut env_vars = BTreeMap::new();
        env_vars.insert(Edn::Key("EDITOR"), Edn::Str("nvim"));
        env_vars.insert(Edn::Str("BROWSER"), Edn::Str("firefox"));

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("env"), Edn::Map(env_vars));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# Environment Variables"));
        assert!(result.contains("set -gx EDITOR 'nvim'"));
        assert!(result.contains("set -gx BROWSER 'firefox'"));
    }

    #[test]
    fn test_paths() {
        let paths = vec![
            Edn::Str("/usr/local/bin"),
            Edn::Str("~/.local/bin"),
            Edn::Str("~/.cargo/bin"),
        ];

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("paths"), Edn::Vector(paths));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# PATH additions"));
        assert!(result.contains("fish_add_path /usr/local/bin"));
        assert!(result.contains("fish_add_path ~/.local/bin"));
        assert!(result.contains("fish_add_path ~/.cargo/bin"));
    }

    #[test]
    fn test_functions_simple() {
        let mut functions = BTreeMap::new();
        functions.insert(
            Edn::Key("mkcd"),
            Edn::Str("mkdir -p $argv[1]; and cd $argv[1]"),
        );

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("functions"), Edn::Map(functions));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# Functions"));
        assert!(result.contains("function mkcd"));
        assert!(result.contains("    mkdir -p $argv[1]; and cd $argv[1]"));
        assert!(result.contains("end"));
    }

    #[test]
    fn test_functions_multiline() {
        let mut functions = BTreeMap::new();
        functions.insert(
            Edn::Key("extract"),
            Edn::Str("switch $argv[1]\\ncase '*.tar.gz'\\n    tar -xzf $argv[1]\\ncase '*.zip'\\n    unzip $argv[1]\\nend")
        );

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("functions"), Edn::Map(functions));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("function extract"));
        assert!(result.contains("    switch $argv[1]"));
        assert!(result.contains("    case '*.tar.gz'"));
        assert!(result.contains("        tar -xzf $argv[1]"));
        assert!(result.contains("    case '*.zip'"));
        assert!(result.contains("        unzip $argv[1]"));
        assert!(result.contains("    end"));
        assert!(result.contains("end"));
    }

    #[test]
    fn test_raw_fish_commands() {
        let commands = vec![
            Edn::Str("set -g fish_prompt_pwd_dir_length 3"),
            Edn::Str("set -g fish_color_command blue"),
        ];

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("fish"), Edn::Vector(commands));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# Custom Fish Commands"));
        assert!(result.contains("set -g fish_prompt_pwd_dir_length 3"));
        assert!(result.contains("set -g fish_color_command blue"));
    }

    #[test]
    fn test_prompt_configuration() {
        let mut prompt_config = BTreeMap::new();
        prompt_config.insert(Edn::Key("style"), Edn::Str("robbyrussell"));
        prompt_config.insert(Edn::Key("show-git"), Edn::Bool(true));

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("prompt"), Edn::Map(prompt_config));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# Prompt Configuration"));
        assert!(result.contains("set -g theme robbyrussell"));
        assert!(result.contains("set -g fish_prompt_show_git true"));
    }

    #[test]
    fn test_prompt_configuration_false() {
        let mut prompt_config = BTreeMap::new();
        prompt_config.insert(Edn::Key("show-git"), Edn::Bool(false));

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("prompt"), Edn::Map(prompt_config));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("set -g fish_prompt_show_git false"));
    }

    #[test]
    fn test_snippets() {
        let mut config_map = BTreeMap::new();
        config_map.insert(
            Edn::Key("snippet/welcome"),
            Edn::Str("# Welcome script\\necho 'Hello, Fish!'"),
        );
        config_map.insert(
            Edn::Key("snippet/custom"),
            Edn::Str("# Custom initialization\\nset -g MY_VAR value"),
        );

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.contains("# welcome"));
        assert!(result.contains("# Welcome script"));
        assert!(result.contains("echo 'Hello, Fish!'"));
        assert!(result.contains("# custom"));
        assert!(result.contains("# Custom initialization"));
        assert!(result.contains("set -g MY_VAR value"));
    }

    #[test]
    fn test_preambles() {
        let mut preambles = BTreeMap::new();
        preambles.insert(
            Edn::Key("tilde/all"),
            Edn::Str("# Generated by tilde\\n# Do not edit manually\\n"),
        );

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("preambles"), Edn::Map(preambles));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        assert!(result.starts_with("# Generated by tilde\n# Do not edit manually\n"));
    }

    #[test]
    fn test_edge_cases() {
        // Test with empty strings and nil values
        let mut config_map = BTreeMap::new();

        // Empty aliases map
        config_map.insert(Edn::Key("aliases"), Edn::Map(BTreeMap::new()));

        // Empty paths vector
        config_map.insert(Edn::Key("paths"), Edn::Vector(vec![]));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        // Should still generate section headers even for empty collections
        assert!(result.contains("# Aliases"));
        assert!(result.contains("# PATH additions"));
    }

    #[test]
    fn test_invalid_types_ignored() {
        // Test that invalid value types are gracefully ignored
        let mut aliases = BTreeMap::new();
        aliases.insert(Edn::Key("valid"), Edn::Str("ls -la"));
        aliases.insert(Edn::Key("invalid"), Edn::Int(42)); // Invalid type

        let mut config_map = BTreeMap::new();
        config_map.insert(Edn::Key("aliases"), Edn::Map(aliases));

        let config = Edn::Map(config_map);
        let result = fish_config(config);

        // Should include valid alias but ignore invalid one
        assert!(result.contains("alias valid 'ls -la'"));
        assert!(!result.contains("42"));
    }

    #[test]
    fn test_non_map_config() {
        // Test with non-map config (should return basic config)
        let config = Edn::Str("not a map");
        let result = fish_config(config);

        assert!(result.contains("# Basic fish configuration"));
    }

    #[test]
    fn test_truly_empty_config() {
        // Test that empty config map produces minimal output
        let config = Edn::Map(BTreeMap::new());
        let result = fish_config(config);

        // Should be just whitespace since no sections are populated
        assert!(result.trim().is_empty());
    }
}
