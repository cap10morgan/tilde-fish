//! Test helpers and utilities for tilde-fish tests
//!
//! This module provides common test fixtures, utilities, and helper functions
//! used across different test modules.

use clojure_reader::edn::Edn;
use std::collections::BTreeMap;

/// Creates a minimal valid EDN configuration for testing
pub fn minimal_config() -> Edn<'static> {
    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("fish-greeting"), Edn::Str("Test greeting"));
    Edn::Map(config_map)
}

/// Creates a comprehensive EDN configuration with all supported features
pub fn comprehensive_config() -> Edn<'static> {
    // Preambles
    let mut preambles = BTreeMap::new();
    preambles.insert(
        Edn::Key("tilde/all"),
        Edn::Str("# Generated by tilde-fish test\\n# Test configuration\\n"),
    );

    // Abbreviations
    let mut abbrs = BTreeMap::new();
    abbrs.insert(Edn::Key("gs"), Edn::Str("git status"));
    abbrs.insert(Edn::Key("gc"), Edn::Str("git commit"));
    abbrs.insert(Edn::Key("gp"), Edn::Str("git push"));
    abbrs.insert(Edn::Key("gl"), Edn::Str("git log --oneline"));

    // Aliases
    let mut aliases = BTreeMap::new();
    aliases.insert(Edn::Key("ll"), Edn::Str("ls -la"));
    aliases.insert(Edn::Key("la"), Edn::Str("ls -A"));
    aliases.insert(Edn::Key("l"), Edn::Str("ls -CF"));
    aliases.insert(Edn::Key("grep"), Edn::Str("grep --color=auto"));
    aliases.insert(Edn::Str("egrep"), Edn::Str("egrep --color=auto"));

    // Environment variables
    let mut env_vars = BTreeMap::new();
    env_vars.insert(Edn::Key("EDITOR"), Edn::Str("nvim"));
    env_vars.insert(Edn::Key("BROWSER"), Edn::Str("firefox"));
    env_vars.insert(Edn::Key("TERM"), Edn::Str("xterm-256color"));
    env_vars.insert(Edn::Str("PAGER"), Edn::Str("less"));

    // Paths
    let paths = vec![
        Edn::Str("/usr/local/bin"),
        Edn::Str("~/.local/bin"),
        Edn::Str("~/.cargo/bin"),
        Edn::Str("/opt/homebrew/bin"),
    ];

    // Functions
    let mut functions = BTreeMap::new();
    functions.insert(
        Edn::Key("mkcd"),
        Edn::Str("mkdir -p $argv[1]; and cd $argv[1]"),
    );
    functions.insert(
        Edn::Key("extract"),
        Edn::Str("switch $argv[1]\ncase '*.tar.gz'\n    tar -xzf $argv[1]\ncase '*.zip'\n    unzip $argv[1]\ncase '*.tar.bz2'\n    tar -xjf $argv[1]\ncase '*'\n    echo 'Unknown archive type'\nend")
    );
    functions.insert(Edn::Str("backup"), Edn::Str("cp $argv[1] $argv[1].bak"));

    // Raw fish commands
    let fish_commands = vec![
        Edn::Str("set -g fish_prompt_pwd_dir_length 3"),
        Edn::Str("set -g fish_color_command blue"),
        Edn::Str("set -g fish_color_param cyan"),
        Edn::Str("set -g fish_greeting"),
    ];

    // Prompt configuration
    let mut prompt_config = BTreeMap::new();
    prompt_config.insert(Edn::Key("style"), Edn::Str("robbyrussell"));
    prompt_config.insert(Edn::Key("show-git"), Edn::Bool(true));

    // Assemble the main configuration
    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("preambles"), Edn::Map(preambles));
    config_map.insert(
        Edn::Key("fish-greeting"),
        Edn::Str("Welcome to comprehensive test!"),
    );
    config_map.insert(
        Edn::Key("snippet/init"),
        Edn::Str("# Initialization snippet\necho 'Fish shell loaded'"),
    );
    config_map.insert(
        Edn::Key("snippet/cleanup"),
        Edn::Str("# Cleanup functions\nfunction cleanup\n    echo 'Cleaning up...'\nend"),
    );
    config_map.insert(Edn::Key("abbrs"), Edn::Map(abbrs));
    config_map.insert(Edn::Key("aliases"), Edn::Map(aliases));
    config_map.insert(Edn::Key("env"), Edn::Map(env_vars));
    config_map.insert(Edn::Key("paths"), Edn::Vector(paths));
    config_map.insert(Edn::Key("functions"), Edn::Map(functions));
    config_map.insert(Edn::Key("fish"), Edn::Vector(fish_commands));
    config_map.insert(Edn::Key("prompt"), Edn::Map(prompt_config));

    Edn::Map(config_map)
}

/// Creates an EDN configuration with edge cases and special characters
pub fn edge_case_config() -> Edn<'static> {
    let mut aliases = BTreeMap::new();
    aliases.insert(Edn::Key("quote-test"), Edn::Str("echo 'hello \"world\"'"));
    aliases.insert(
        Edn::Key("backslash-test"),
        Edn::Str("echo 'path\\to\\file'"),
    );
    aliases.insert(
        Edn::Key("newline-test"),
        Edn::Str("echo 'line1'; echo 'line2'"),
    );
    aliases.insert(
        Edn::Key("unicode-test"),
        Edn::Str("echo '🐟 Fish shell! 中文 Русский'"),
    );

    let mut env_vars = BTreeMap::new();
    env_vars.insert(Edn::Key("SPECIAL_CHARS"), Edn::Str("!@#$%^&*()"));
    env_vars.insert(Edn::Key("EMPTY_VAR"), Edn::Str(""));
    env_vars.insert(Edn::Key("SPACES_VAR"), Edn::Str("value with spaces"));

    let paths = vec![
        Edn::Str("/path with spaces/bin"),
        Edn::Str("/path-with-dashes/bin"),
        Edn::Str("/path_with_underscores/bin"),
        Edn::Str("/path.with.dots/bin"),
    ];

    let mut functions = BTreeMap::new();
    functions.insert(
        Edn::Key("complex-function"),
        Edn::Str("if test (count $argv) -eq 0\n    echo 'Error: No arguments'\n    return 1\nend\n\nfor file in $argv\n    if test -f $file\n        echo 'Processing: $file'\n    else\n        echo 'Warning: $file not found'\n    end\nend")
    );

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("aliases"), Edn::Map(aliases));
    config_map.insert(Edn::Key("env"), Edn::Map(env_vars));
    config_map.insert(Edn::Key("paths"), Edn::Vector(paths));
    config_map.insert(Edn::Key("functions"), Edn::Map(functions));
    config_map.insert(Edn::Key("fish-greeting"), Edn::Str(""));

    Edn::Map(config_map)
}

/// Creates an EDN configuration with only empty collections
pub fn empty_collections_config() -> Edn<'static> {
    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("aliases"), Edn::Map(BTreeMap::new()));
    config_map.insert(Edn::Key("env"), Edn::Map(BTreeMap::new()));
    config_map.insert(Edn::Key("paths"), Edn::Vector(Vec::new()));
    config_map.insert(Edn::Key("functions"), Edn::Map(BTreeMap::new()));
    config_map.insert(Edn::Key("fish"), Edn::Vector(Vec::new()));
    config_map.insert(Edn::Key("abbrs"), Edn::Map(BTreeMap::new()));

    Edn::Map(config_map)
}

/// Creates an EDN configuration for testing different fish greeting scenarios
pub fn greeting_variants_config(greeting: Option<&'static str>) -> Edn<'static> {
    let mut config_map = BTreeMap::new();

    match greeting {
        Some(msg) => {
            config_map.insert(Edn::Key("fish-greeting"), Edn::Str(msg));
        }
        None => {
            // Insert Nil to test the disable greeting case
            config_map.insert(Edn::Key("fish-greeting"), Edn::Nil);
        }
    }

    Edn::Map(config_map)
}

/// Creates a large configuration for performance testing
pub fn large_config(size_multiplier: usize) -> Edn<'static> {
    let mut aliases = BTreeMap::new();
    for i in 0..(50 * size_multiplier) {
        aliases.insert(
            Edn::Key(Box::leak(format!("alias_{:04}", i).into_boxed_str())),
            Edn::Str(Box::leak(
                format!("command_{} --flag-{}", i, i).into_boxed_str(),
            )),
        );
    }

    let mut env_vars = BTreeMap::new();
    for i in 0..(20 * size_multiplier) {
        env_vars.insert(
            Edn::Key(Box::leak(format!("VAR_{}", i).into_boxed_str())),
            Edn::Str(Box::leak(format!("value_{}", i).into_boxed_str())),
        );
    }

    let mut paths = Vec::new();
    for i in 0..(10 * size_multiplier) {
        paths.push(Edn::Str(Box::leak(
            format!("/path/to/bin/{}", i).into_boxed_str(),
        )));
    }

    let mut functions = BTreeMap::new();
    for i in 0..(15 * size_multiplier) {
        functions.insert(
            Edn::Key(Box::leak(format!("func_{}", i).into_boxed_str())),
            Edn::Str(Box::leak(
                format!("echo 'Function {} executed'\nset -l var_{} value", i, i).into_boxed_str(),
            )),
        );
    }

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("aliases"), Edn::Map(aliases));
    config_map.insert(Edn::Key("env"), Edn::Map(env_vars));
    config_map.insert(Edn::Key("paths"), Edn::Vector(paths));
    config_map.insert(Edn::Key("functions"), Edn::Map(functions));

    Edn::Map(config_map)
}

/// Asserts that a fish config output contains the expected section headers
pub fn assert_sections_present(output: &str, sections: &[&str]) {
    for section in sections {
        assert!(
            output.contains(section),
            "Output should contain section: {}",
            section
        );
    }
}

/// Asserts that a fish config output has sections in the correct order
pub fn assert_sections_ordered(output: &str, sections: &[&str]) {
    let mut last_position = 0;

    for section in sections {
        if let Some(position) = output.find(section) {
            assert!(
                position >= last_position,
                "Section '{}' should come after previous sections",
                section
            );
            last_position = position;
        }
    }
}

/// Validates that the output contains valid fish shell syntax
pub fn validate_fish_syntax(output: &str) {
    // Basic syntax validation

    // Check that all 'function' declarations have matching 'end'
    let function_count = output.matches("function ").count();
    let end_count = output.matches("\nend\n").count() + output.matches("\nend").count();
    assert!(
        end_count >= function_count,
        "All function declarations should have matching 'end' statements"
    );

    // Check that aliases are properly quoted
    for line in output.lines() {
        if line.trim().starts_with("alias ") {
            assert!(
                line.contains('\''),
                "Alias commands should be quoted: {}",
                line
            );
        }
    }

    // Check that environment variables use proper syntax
    for line in output.lines() {
        if line.trim().starts_with("set -gx ") {
            let parts: Vec<&str> = line.split_whitespace().collect();
            assert!(
                parts.len() >= 3,
                "Environment variable declarations should have variable name and value: {}",
                line
            );
        }
    }

    // Check that fish_add_path commands are properly formatted
    for line in output.lines() {
        if line.trim().starts_with("fish_add_path ") {
            let parts: Vec<&str> = line.split_whitespace().collect();
            assert!(
                parts.len() >= 2,
                "fish_add_path should have a path argument: {}",
                line
            );
        }
    }
}

/// Parses an EDN string and returns the result, panicking with a helpful message on failure
pub fn parse_edn_or_panic(edn_str: &str) -> Edn {
    clojure_reader::edn::read_string(edn_str)
        .unwrap_or_else(|e| panic!("Failed to parse EDN: {}\nEDN content: {}", e, edn_str))
}

/// Creates a test config with specific aliases for testing alias functionality
pub fn aliases_test_config(aliases: Vec<(&'static str, &'static str)>) -> Edn<'static> {
    let mut aliases_map = BTreeMap::new();

    for (name, command) in aliases {
        aliases_map.insert(Edn::Key(name), Edn::Str(command));
    }

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("aliases"), Edn::Map(aliases_map));

    Edn::Map(config_map)
}

/// Creates a test config with specific environment variables
pub fn env_vars_test_config(env_vars: Vec<(&'static str, &'static str)>) -> Edn<'static> {
    let mut env_map = BTreeMap::new();

    for (name, value) in env_vars {
        env_map.insert(Edn::Key(name), Edn::Str(value));
    }

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("env"), Edn::Map(env_map));

    Edn::Map(config_map)
}

/// Creates a test config with specific paths
pub fn paths_test_config(paths: Vec<&'static str>) -> Edn<'static> {
    let paths_vec: Vec<Edn> = paths.into_iter().map(|p| Edn::Str(p)).collect();

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("paths"), Edn::Vector(paths_vec));

    Edn::Map(config_map)
}

/// Creates a test config with specific functions
pub fn functions_test_config(functions: Vec<(&'static str, &'static str)>) -> Edn<'static> {
    let mut functions_map = BTreeMap::new();

    for (name, body) in functions {
        functions_map.insert(Edn::Key(name), Edn::Str(body));
    }

    let mut config_map = BTreeMap::new();
    config_map.insert(Edn::Key("functions"), Edn::Map(functions_map));

    Edn::Map(config_map)
}

/// Extracts all alias definitions from fish config output
pub fn extract_aliases(output: &str) -> Vec<(String, String)> {
    let mut aliases = Vec::new();

    for line in output.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("alias ") {
            if let Some(rest) = trimmed.strip_prefix("alias ") {
                if let Some(space_pos) = rest.find(' ') {
                    let name = rest[..space_pos].to_string();
                    let command = rest[space_pos + 1..].trim_matches('\'').to_string();
                    aliases.push((name, command));
                }
            }
        }
    }

    aliases
}

/// Extracts all environment variable definitions from fish config output
pub fn extract_env_vars(output: &str) -> Vec<(String, String)> {
    let mut env_vars = Vec::new();

    for line in output.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("set -gx ") {
            if let Some(rest) = trimmed.strip_prefix("set -gx ") {
                let parts: Vec<&str> = rest.splitn(2, ' ').collect();
                if parts.len() == 2 {
                    let name = parts[0].to_string();
                    let value = parts[1].trim_matches('\'').to_string();
                    env_vars.push((name, value));
                }
            }
        }
    }

    env_vars
}

/// Extracts all path additions from fish config output
pub fn extract_paths(output: &str) -> Vec<String> {
    let mut paths = Vec::new();

    for line in output.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("fish_add_path ") {
            if let Some(path) = trimmed.strip_prefix("fish_add_path ") {
                paths.push(path.to_string());
            }
        }
    }

    paths
}

/// Test constants for common expected outputs
pub mod constants {
    pub const ALIASES_HEADER: &str = "# Aliases";
    pub const ABBRS_HEADER: &str = "# Abbreviations";
    pub const ENV_VARS_HEADER: &str = "# Environment Variables";
    pub const PATHS_HEADER: &str = "# PATH additions";
    pub const FUNCTIONS_HEADER: &str = "# Functions";
    pub const FISH_COMMANDS_HEADER: &str = "# Custom Fish Commands";
    pub const PROMPT_HEADER: &str = "# Prompt Configuration";

    pub const BASIC_CONFIG_COMMENT: &str = "# Basic fish configuration";

    pub const ALL_SECTION_HEADERS: &[&str] = &[
        ALIASES_HEADER,
        ABBRS_HEADER,
        ENV_VARS_HEADER,
        PATHS_HEADER,
        FUNCTIONS_HEADER,
        FISH_COMMANDS_HEADER,
        PROMPT_HEADER,
    ];
}

#[cfg(test)]
mod tests {
    use super::*;
    use tilde_fish::fish_config;

    #[test]
    fn test_minimal_config() {
        let config = minimal_config();
        let output = fish_config(config);
        assert!(output.contains("set fish_greeting 'Test greeting'"));
    }

    #[test]
    fn test_comprehensive_config() {
        let config = comprehensive_config();
        let output = fish_config(config);

        // Verify all sections are present
        assert_sections_present(&output, constants::ALL_SECTION_HEADERS);

        // Verify some specific content
        assert!(output.contains("alias ll 'ls -la'"));
        assert!(output.contains("set -gx EDITOR 'nvim'"));
        assert!(output.contains("fish_add_path /usr/local/bin"));
        assert!(output.contains("function mkcd"));
    }

    #[test]
    fn test_edge_case_config() {
        let config = edge_case_config();
        let output = fish_config(config);

        validate_fish_syntax(&output);
        assert!(output.contains("unicode-test"));
        assert!(output.contains("set fish_greeting ''"));
    }

    #[test]
    fn test_extract_aliases() {
        let output = "alias ll 'ls -la'\nalias grep 'grep --color=auto'\n";
        let aliases = extract_aliases(output);

        assert_eq!(aliases.len(), 2);
        assert!(aliases.contains(&("ll".to_string(), "ls -la".to_string())));
        assert!(aliases.contains(&("grep".to_string(), "grep --color=auto".to_string())));
    }

    #[test]
    fn test_validate_fish_syntax() {
        let valid_output = r#"
function test_func
    echo 'hello'
end

alias ll 'ls -la'
set -gx EDITOR 'nvim'
fish_add_path /usr/local/bin
"#;

        validate_fish_syntax(valid_output);
    }
}
